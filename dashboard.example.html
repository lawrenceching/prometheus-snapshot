<html lang="en">
<head>
    <title>Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.5.0/echarts.min.js"
            integrity="sha512-k37wQcV4v2h6jgYf5IUz1MoSKPpDs630XGSmCaCCOXxy2awgAWKHGZWr9nMyGgk3IOxA1NxdkN8r1JHgkUtMoQ=="
            crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
            crossorigin="anonymous"></script>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #dashboard {
            display: flex;
            flex-direction: column;
            gap: 100px;
            padding: 10px 10px 10px 10px;
        }

        #control {
            padding: 10px;
        }

        .tile {
            margin: auto;
            height: 30%;
        }

        .container {
            /*margin: 50px 10px;*/
        }

        .chart {
            width: 1500px;
            height: 1500px;
        }

        .divider {
            background-color: grey;
            width: 100%;
            height: 1px;
        }

        .chart svg {
            user-select: auto !important;
        }


        /*.container {*/
        /*    display: flex;*/
        /*    flex-direction: row*/
        /*}*/
    </style>
</head>
<body>
<h1>Dashboard</h1>
<div id="control">
    <div class="mb-3">
        <label for="dataSource" class="form-label">Data Source</label>
        <input class="form-control" id="dataSource" placeholder="https://prometheus.demo.do.prometheus.io">
    </div>
    <div class="mb-3">
        <label for="dashboardDefinition" class="form-label">Dashboard</label>
        <textarea class="form-control" id="dashboardDefinition" rows="3"></textarea>
        <button id="btn-update">Update</button>
    </div>
</div>
<div id="dashboard" class="container text-center">
</div>
<div id="data" hidden>
</div>
<script id="persistent-data">
    window.originFetch = window.fetch;
    window.fetch = function (url) {
        const cacheResp = window.fetchCache[url];
        if (cacheResp !== undefined) {
            console.log(`return cached HTTP response: ${url}`)
            return {
                ok: true,
                url: url,
                json: async () => {
                    return JSON.parse(cacheResp)
                },
                text: async () => {
                    return cacheResp;
                }
            }
        }

        return window.originFetch.apply(null, arguments)
    }
    // map of URL to HTTP response
    window.fetchCache = {}

</script>

<script type="module">

    {
        // START
        const SUPPORTED_UNITS = {
            percent_0_to_1: 'Percent (0.0-1.0)',
            second: 'second',
            bytes: 'bytes',
            number: 'number'
        };


        const defaultOptions = {
            unit: SUPPORTED_UNITS.number,
        }

        const formatters = {};
        formatters[SUPPORTED_UNITS.bytes] = (value) => {
            const b = 1;
            const kb = 1000 * b;
            const mb = 1000 * kb;
            const gb = 1000 * mb;
            const tb = 1000 * gb;
            if (value > tb) {
                return `${(value / tb).toFixed(2)} TB`;
            }
            if (value > gb) {
                return `${(value / gb).toFixed(2)} GB`;
            }
            if (value > mb) {
                return `${(value / mb).toFixed(2)} MB`;
            }
            if (value > kb) {
                return `${(value / kb).toFixed(2)} KB`;
            }
            return `${(value / kb).toFixed(2)} B`;
        };

        formatters[SUPPORTED_UNITS.percent_0_to_1] = (value) => {
            return `${(parseFloat(value) * 100).toFixed(2)}%`;
        }

        formatters[SUPPORTED_UNITS.second] = (value) => {
            return `${value}ms`
        }

        formatters[SUPPORTED_UNITS.number] = (value) => {
            return `${value}`
        }

        /**
         * {
         *                     "handler": "subroute",
         *                     "instance": "localhost:2019",
         *                     "job": "caddy",
         *                     "server": "srv0",
         *                     "<other metric key>": "<other values>"
         * }
         * @param metric
         */
        function nameOf(metric) {
            const labels = []
            for (const [key, value] of Object.entries(metric)) {
                labels.push(`${key}=${value}`)
            }
            return labels.join(' ');
        }

        /**

         * dataSet is:
         * [
         *             {
         *                 "metric": {
         *                     "handler": "subroute",
         *                     "instance": "localhost:2019",
         *                     "job": "caddy",
         *                     "server": "srv0"
         *                 },
         *                 "values": [
         *                     [
         *                         1714492874.299,
         *                         "1.3555555555555554"
         *                     ],
         *                     [
         *                         1714496472.299,
         *                         "1.2"
         *                     ]
         *                 ]
         *             }
         * ]
         * @param dataSet
         * @param options
         */
        function buildEchartOption(panel, dataSet, options) {
            const {
                title,
                subtitle,
                renderer,
                unit,
                headless,
                width,
                height,
                output,
                showLegend
            } = Object.assign({}, defaultOptions, options);

            return {
                tooltip: {
                    trigger: 'axis',
                    showContent: true,
                    valueFormatter: function (value) {
                        const formatter = !!formatters[unit] ? formatters[unit] : (v) => v;
                        return formatter(value);
                    },
                    position: function (pt) {
                        return [pt[0], '10%'];
                    }
                },
                title: {
                    left: 'center',
                    text: panel.title,
                    textStyle: {
                        fontSize: 24,
                        fontWeight: 'bold',
                    },
                    subtext: panel.query
                },
                backgroundColor: "#FFF",
                animation: false,
                // legend: {
                //     left: 'right',
                //     show: showLegend,
                //     top: 'center',
                //     orient: 'vertical',
                //     icon: 'circle',
                //     data: dataSet.length > 10 ? null : dataSet.map(d => d.name)
                // },
                grid: {
                    left: '3%',
                    right: '15%',
                    bottom: '3%',
                    containLabel: true,
                    show: false,
                    backgroundColor: '#fff'
                },
                toolbox: {
                    show: true,
                    feature: {
                        saveAsImage: {}
                    }
                },
                xAxis: {
                    type: 'time',
                    boundaryGap: false,
                    splitNumber: 5,
                    axisLabel: {
                        formatter: function (value, index) {
                            const date = new Date(value);
                            return `${date.getHours()}/${date.getMinutes()}`
                        }
                    }
                },
                yAxis: {
                    type: 'value',
                    boundaryGap: [0, '20%'],
                    axisLabel: {
                        formatter: function (value, index) {
                            const formatter = !!formatters[unit] ? formatters[unit] : (v) => v;
                            return formatter(value);
                        }
                    }
                },
                legend: {
                    show: true,
                    orient: 'vertical',
                    left: 'right',
                    data: ['Email', 'Union Ads', 'Video Ads', 'Direct', 'Search Engine'],
                },
                series: dataSet.map(item => {
                    return {
                        name: nameOf(item.metric),
                        type: 'line',
                        smooth: true,
                        symbol: 'none',
                        xAxis: {
                            type: 'time',
                            boundaryGap: false
                        },
                        yAxis: {
                            type: 'value',
                            boundaryGap: [0, '100%']
                        },
                        /**
                         * data is an array that contains a list of arrays:
                         * [
                         *     [1714492874.299,"1.3555555555555554"],
                         *     [1714492888.299,"1.2444444444444442"]
                         * ]
                         *
                         * The inner array has two item, the first item is timestamp in unix milliseconds, and second item is the value
                         */
                        data: item.values.map(value => {
                            const timestampInUnixSeconds = value[0];
                            let number = value[1] === "NaN" ? 0 : value[1];

                            switch (unit) {
                                case SUPPORTED_UNITS.second : {
                                    number = number * 1000;
                                    break;
                                }
                            }

                            return [
                                timestampInUnixSeconds,
                                Math.floor(number * 100) / 100
                            ]
                        })
                    }
                })
            };
        }

        window.EchartOptionBuilder={}
        window.EchartOptionBuilder.buildEchartOption = buildEchartOption;
        window.EchartOptionBuilder.UNITS = SUPPORTED_UNITS;
    }

    {
        const DEFAULT_OPTIONS = {
            step: 14
        }

        function getName(result) {
            const labels = []
            for(let key in result.metric) {
                if (result.metric.hasOwnProperty(key)) {
                    labels.push(`${key}=${result.metric[key]}`)
                }
            }
            return labels.join(" ")
        }

        class Prometheus {

            constructor(url) {
                this.url = url;
            }

            async queryRange (promQL, startInSeconds, endInSeconds, _options) {

                const options = Object.assign({}, DEFAULT_OPTIONS, _options)

                const url = new URL(`${this.url}/api/v1/query_range`);
                url.searchParams.append('query', promQL)
                url.searchParams.append('start', startInSeconds)
                url.searchParams.append('end', endInSeconds)
                url.searchParams.append('step', options.step)
                // log(`> ${url.href}`)
                const resp = await fetch(url.href)

                // window.fetchCache[url] = resp;

                return resp;
            }

            async queryRangeSince (promQL, durationInSeconds, options) {
                const endInSeconds = Date.now() / 1000;
                const startInSeconds = endInSeconds - durationInSeconds;
                return await this.queryRange(promQL, startInSeconds, endInSeconds, options);
            }

        }

        window.Prometheus = Prometheus
    }


    class DashboardManager {

        static KEY_DEFINITION = 'definition'

        definition

        init() {
            console.log(`initializing dashboard manager`)

            this.definition = JSON.parse(this.load(DashboardManager.KEY_DEFINITION));
        }

        static #findElement(key) {
            return document.querySelector(`#data div#pd-${key}`)
        }

        load(key) {
            const el = DashboardManager.#findElement(key)
            const v = (el === null || el === undefined) ? null : el.innerText;
            console.log(`loaded ${key}: ${v}`)
            return v;
        }

        save(key, value) {

            console.log(`save ${key}: ${value}`)
            let el = this.load(key);
            if(el == null) {
                console.log(`save ${key} to new div`)
                const root = document.querySelector(`#data`)
                el = document.createElement('div')
                el.id = `pd-${key}`
                root.appendChild(el)

            } else {
                console.log(`save ${key} to exist div`)
                el = DashboardManager.#findElement(key)
            }

            el.innerText = value

        }

        setDefinition(newValue) {
            this.save(DashboardManager.KEY_DEFINITION, newValue)
            this.definition = newValue;
        }
    }

    const dm  = window.dm = new DashboardManager()
    dm.init()

    window.echartOptions = {
        renderer: 'svg'
    }

    const buildEchartOption = window.EchartOptionBuilder.buildEchartOption;
    const UNITS = window.EchartOptionBuilder.UNITS;
    const Prometheus = window.Prometheus;

    const TYPE_TIME_SERIES = 'time-series';
    const TYPE_ROW = 'row'; // a row contains another set of panels
    function renderExampleTimeSeries(panel, elementId) {
        var chart = echarts.init(document.getElementById(elementId));

        const now = Date.now();
        const dataSet = [
            {
                metric: 'pod-name_container_name',
                values: [
                    {time: now + 1000 * 10, value: Math.floor(Math.random())},
                    {time: now + 1000 * 20, value: Math.floor(Math.random())},
                    {time: now + 1000 * 30, value: Math.floor(Math.random())},
                    {time: now + 1000 * 40, value: Math.floor(Math.random())},
                    {time: now + 1000 * 50, value: Math.floor(Math.random())},
                    {time: now + 1000 * 60, value: Math.floor(Math.random())},
                    {time: now + 1000 * 70, value: Math.floor(Math.random())},
                    {time: now + 1000 * 80, value: Math.floor(Math.random())},
                    {time: now + 1000 * 90, value: Math.floor(Math.random())},
                    {time: now + 1000 * 100, value: Math.floor(Math.random())},
                ]
            }
        ]
        const option = buildEchartOption(panel, dataSet, {
            unit: panel.unit,
        })
        chart.setOption(option);
    }

    /**

     * data is:
     * [
     *             {
     *                 "metric": {
     *                     "handler": "subroute",
     *                     "instance": "localhost:2019",
     *                     "job": "caddy",
     *                     "server": "srv0"
     *                 },
     *                 "values": [
     *                     [
     *                         1714492874.299,
     *                         "1.3555555555555554"
     *                     ],
     *                     [
     *                         1714496472.299,
     *                         "1.2"
     *                     ]
     *                 ]
     *             }
     *
     * @param panel
     * @param elementId
     * @param data
     */
    function renderTimeSeries(panel, elementId, data) {
        console.log(`render time series panel: data=${JSON.stringify(data)}`)
        var chart = echarts.init(document.getElementById(elementId), null, {
            renderer: window.echartOptions.renderer || 'svg',
            useDirtyRect: false
        });

        const option = buildEchartOption(panel, data, {
            unit: panel.unit,
        })
        chart.setOption(option);
        console.log(`register resize event listener for echart ${panel.title}`);
        window.addEventListener('resize', chart.resize)
    }

    function prometheusResponseToEchartData(resp) {

        /**
         * resp is:
         * {
         *     "status": "success",
         *     "data": {
         *         "resultType": "matrix",
         *         "result": [
         *             {
         *                 "metric": {
         *                     "handler": "subroute",
         *                     "instance": "localhost:2019",
         *                     "job": "caddy",
         *                     "server": "srv0"
         *                 },
         *                 "values": [
         *                     [
         *                         1714492874.299,
         *                         "1.3555555555555554"
         *                     ],
         *                     [
         *                         1714496472.299,
         *                         "1.2"
         *                     ]
         *                 ]
         *             }
         *         ]
         *     }
         * }
         */

        return resp.data.result;

    }

    function onDashboardUpdated(dashboard) {

        function renderPanelInElement(panel) {
            const id = "echart-" + uuidv4();
            const { title, query } = panel;

            echartInitFunctions.push(async () => {
                const query  = panel.query;
                const resp = await prometheus.queryRange(query, startTimeInUnixSeconds, endTimeInUnixSeconds);
                let data = null;
                if (!resp.ok) {
                    console.log(`failed to fetch data from ${address}`)
                } else {
                    const json = data = await resp.json();
                    window.fetchCache[resp.url] = JSON.stringify(json);
                    console.log(`persistent "${title}" data into HTML`);
                }

                renderTimeSeries(panel, id, prometheusResponseToEchartData(data));
                console.log(`rendered chart ${panel.title} to container ${id}`)
            })

            console.log(`created echart container ${id} for panel ${title}`)

            if (window.echartOptions.renderer === 'svg') {
                return `<div>
                    <div id="${id}" class="chart"></div>
                </div>`
            } else {
                return `<div>
                    <div><h3>${title}</h3></div>
                    <div>${query}</div>
                    <div id="${id}" class="chart"></div>
                </div>`
            }
        }

        function renderPanelsInElement(panels) {
            return panels
                .map(panel => {
                    return `
                <div class="col"> ${renderPanelInElement(panel)}</div>
                `
                })
                .join("\n")
        }

        dashboardEl.innerHTML = ``
        const dashboardAsString = JSON.stringify(dashboard, null, 4);
        dm.save(DashboardManager.KEY_DEFINITION, dashboardAsString)

        const el = document.querySelector("#dashboardDefinition")
        el.value = dashboardAsString;

        const address = dashboard.dataSources[0].address;
        const prometheus = new Prometheus(address);
        const panel = dashboard.panels[0];
        const {title, query} = panel;

        let indexOfPanelId = 0;
        const echartInitFunctions = [];

        const panels = dashboard.panels;
        for (const panel of panels) {

            const {title, query, type} = panel;

            switch (type) {
                case TYPE_TIME_SERIES: {

                    if(query === null || query === undefined || query.trim() === '') {
                        continue;
                    }

                    const id = `panel-${++indexOfPanelId}`;
                    dashboardEl.innerHTML = dashboardEl.innerHTML + `
                <div class="tile row">
                    <div class="panel-title">${panel.title}</div>
                    <div id="${id}" class="col tile">${renderPanelInElement(panel)}</div>
                </div>
                <div class="tile divider"></div>
                `

                    break;
                }
                case TYPE_ROW: {
                    const subPanels = panel.panels;
                    const rowId = `echart-row-${uuidv4()}`;
                    console.log(`rendering row ${title} with ${subPanels.length} sub panels`);
                    dashboardEl.innerHTML = dashboardEl.innerHTML + `

                    <div class="tile container text-center">
                        <div class="row">
                            <div class="h1 panel-title">${panel.title}</div>
                            <button class="btn btn-dark" type="button" data-bs-toggle="collapse" data-bs-target="#${rowId}" aria-expanded="false" aria-controls="${rowId}">Collapse</button>
                        </div>
                        <div class="row collapse show" id="${rowId}">${renderPanelsInElement(subPanels)}</div>

                    </div>
                    <div class="tile divider"></div>
`
                }
            }
        }

        echartInitFunctions.forEach(fn => fn());
    }


    const endTimeInUnixSeconds = Date.now() / 1000
    const startTimeInUnixSeconds = endTimeInUnixSeconds - 900;

    const dashboardEl = document.getElementById('dashboard');

    const defaultDashboardDefinition = {
        title: 'Performance Dashboard',
        dataSources: [
            {
                type: "prometheus",
                address: 'https://prometheus.demo.do.prometheus.io'
            }
        ],
        panels: [
            {
                title: 'CPU Usage',
                type: 'time-series',
                query: "sum(rate(process_cpu_seconds_total[1m])) by (instance, job) * 100",
                unit: UNITS.percent_0_to_1,
                dataSource: 'prometheus'
            },
            {
                title: 'Caddy',
                type: 'row',
                panels: [
                    {
                        title: 'caddy_http_response_duration',
                        type: 'time-series',
                        query: "sum(rate(caddy_http_response_duration_seconds_sum[5m])) by (instance, method, code)/sum(rate(caddy_http_response_duration_seconds_count[5m])) by (instance, method, code)",
                        unit: UNITS.second,
                        dataSource: 'prometheus'
                    },
                    {
                        title: 'caddy_http_response_duration GET 200',
                        type: 'time-series',
                        query: "sum(rate(caddy_http_response_duration_seconds_sum{method=\"GET\", code=\"200\"}[5m])) by (instance, method, code)/sum(rate(caddy_http_response_duration_seconds_count{method=\"GET\", code=\"200\"}[5m])) by (instance, method, code)",
                        unit: UNITS.second,
                        dataSource: 'prometheus'
                    },
                ]
            },
        ]
    }

    const dashboardDefinitionTextArea = document.querySelector("#dashboardDefinition")

    if(dashboardDefinitionTextArea.value === '') {
        dashboardDefinitionTextArea.value = JSON.stringify(defaultDashboardDefinition, null, 4);
        console.log(`initialized default dashboard definition`);
    }

    function uuidv4() {
        return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, c =>
            (+c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> +c / 4).toString(16)
        );
    }

    const updateButton = document.getElementById('btn-update');
    updateButton.addEventListener('click', (e) => {
        const el = document.querySelector("#dashboardDefinition")
        onDashboardUpdated(JSON.parse(el.value));
        console.log(`Update Button: click`)
    })

    let dashboard = JSON.parse(dm.load(DashboardManager.KEY_DEFINITION));
    onDashboardUpdated(dashboard === null ? defaultDashboardDefinition : dashboard);

    window.setDashboardDefinition = function(def) {
        onDashboardUpdated(def)
    }

</script>
</body>
</html>